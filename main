'''
INTRODUCTION: Play sorry with two die, and one peg. Move your piece down the board first. But rolling 
certain numbers will change the pace of the game. 

INCLUDE IN YOUR ASSIGNMENT: Annotation is a major part of any program. At the top of each of your 
C++ programs, you should have at least four lines of documentation:
// Program name: tictactoe.cpp
// Author: Twilight Sparkle
// Date last updated: 5/26/2016
// Purpose: Play the game of Tic-Tac-Toe

ASSIGNMENT: Sorry Game
1.To play “Sorry”, you’ll need to create up to Four players.
Prompt the user for the number of players (2-4).
2. Create two die for the players to roll.
3. Create an Array to be used to track the player’s positions on the playing board.
4. The playing board has 50 spaces (with 50 being the winning SpacescurrentSpaces).
5. The dice have special conditions:
2 = Move two spaces
3 = Move three spaces
4 = Move back one SpacescurrentSpaces.
5 = Move five spaces.
6 = Move six spaces.
7 = Swap spots with the leading layer / or nothing if player is in lead.
8 = Move Eight spaces.
9 = Move nine spaces.
10 = Move ten spaces.
11 = Swap spots with the last player / or do nothing if player is last.
12 = Start Over
6.  A player must roll a double to start.
7.  If a player lands on the same SpacescurrentSpaces as another, the other player must return to the beginning.
Example: If P1 lands on a SpacescurrentSpaces where P3 is, P3 would go back to the start.
8. A player must roll an EXACT number to enter the winning SpacescurrentSpaces.
9. Use a random Generator to “roll” the dice, the user must press enter to roll. TODO (LAST)
10. Depict the players’ positions on the screen after each round.
11. Once a player finishes, create a winning message announcing the winner.
12. Then ask the user if they would like to play again.
13. You must use at least three functions. Some function examples could be:
Roll dice, check for other player (when moving), display board TODO.
14. Display the status/location of the players between sets of rolls.
15. Depict a Playing Board on the screen and display the Players’ position on the board. (Extra Credit) TODO
(maybe try using a method to create the board and screen each time a player moves)
16. If a player rolls a double, they’ll get another roll (Extra Credit).
17. If a player rolls two doubles in a row, they Start Over (Extra Credit).
'''

import random

# Rolls two dice and returns each die number as well as roll total
def rollDice(player):
    print()
    print("Player " + str(player + 1) + " turn.")
    die1 = random.randint(1,6)
    die2 = random.randint(1,6)
    sum = die1 + die2
    roll = [die1, die2, sum]
    print("You rolled " + str(die1) + " and " + str(die2) + " for a total of " + str(sum) + ".")
    return roll

# Swaps current player with first place
def swapWithFirst(spaces, player):
    max = player
    for i in range(len(spaces)):
        if spaces[i] > spaces[max]:
            max = i
    spaces[player], spaces[max] = spaces[max], spaces[player] 
    if max != player:
        print("Swap with Player " + str(max + 1) + " in first place. ")
    else:
        print("You're already in first place!  Congrats, you stay there. ")
    return spaces

# Swaps current player with last place
# NEED TO CONSIDER IF MULTIPLE PLAYERS ARE AT START
def swapWithLast(spaces, player, initial):
    min = player
    for i in range(len(spaces)):
        # Looks only at players who have already started
        if spaces[i] < spaces[min] and initial[i]:
            min = i
    spaces[player], spaces[min] = spaces[min], spaces[player] 
    if min != player:
        print("Swap with Player " + str(min + 1) + " in last place. ")
    else:
        print("You're already in last place!  Too bad, you stay there. ")
    return spaces

# Checks for SORRY! condition
def checkForSorry(spaces, player):
    for i in range(len(spaces)):
        if i != player:
            if spaces[i] == spaces[player]:
                spaces[i] = 1
                print("SORRY! Player " + str(i + 1) + " return to start!")
                break
        else:
            continue
    return spaces

# Checks for and applies special conditions of roll
def executeRoll(total, spaces, player, initial):
    noMove = spaces[player]
    if total == 4:
        # Move back one space (unless at start)
        if spaces[player] > 1:
            print("Move back one space!")
            spaces[player] -= 1
            spaces = checkForSorry(spaces, player)
        else:
            print("You can't move back because you're at start!  You stay there.")
    elif total == 7:
        spaces = swapWithFirst(spaces, player)
    elif total == 11:
        spaces = swapWithLast(spaces, player, initial)
    elif total == 12:
        # Return to start (unless at start)
        if spaces[player] > 1:
            print("Return to start!")
            spaces[player] = 1
        else:
            print("You're already at start!  You stay there.")
    else:
        print("Move forward " + str(total) + " spaces!")
        spaces[player] += total
        spaces = checkForSorry(spaces, player)
    # Checks for exact roll to win
    if spaces[player] > 50:
        spaces[player] = noMove
        print("Sorry, you need an exact roll to win!  You don't move.")
    print("Current positions: " + str(spaces))
    return spaces

# Checks for doubles and then returns boolean value
def rolledDouble(roll):
    if roll[0] == roll[1]:
        return True
    else:
        return False

# Keeps track of consecutive doubles and applies appropriate conditions
def trackDoubles(roll, spaces, player, doubles, initial):
    if rolledDouble(roll):
        doubles[i] += 1
        if doubles[i] == 1:
            print("You rolled doubles!  Roll again.")
            roll = rollDice(player)
            if rolledDouble(roll):                                
                print("Oh no!  Two doubles in a row.  Bad luck.  Return to start.")
                spaces[i] = 1
            else:
                spaces = executeRoll(roll[2], spaces, player, initial)
                doubles[i] = 0
        # This is turn 2 specific
        if doubles[i] == 2:
            doubles[i] = 0
            print("Oh no!  Two doubles in a row.  Bad luck.  Return to start.")
            spaces[i] = 1
    else:
        doubles[i] = 0
    return [spaces, doubles]

# Repeats games until player says no
newGame = True
while newGame:

    # Repeatedly asks for number of players until player enters valid number
    while True:
        numOfPlayers = input("How many players? (must be 2-4) ")
        if numOfPlayers not in ["2", "3", "4"]:
            print("You must choose a number between 2 and 4!")
            continue
        else:
            break

    # Creates array to keep track of each player's current space number
    currentSpaces = []
    initialDouble = []
    consecutiveDoubles = []
    for i in range(int(numOfPlayers)):
        # Play starts on space 1 (alternatively could start on space 0)
        currentSpaces.append(1)
        initialDouble.append(False)
        consecutiveDoubles.append(0)

    # Loop for turns to continue until there is a winner
    winner = False
    while not winner:

        # One round of turns for each player
        for i in range(len(currentSpaces)):
            firstRoll = False
            currentRoll = rollDice(i)

            # Checks for initial double roll
            if not initialDouble[i]:
                # Player applies conditions of initial double roll to move (alternatively could roll again)
                if rolledDouble(currentRoll):
                    initialDouble[i] = True
                    firstRoll = True
                    consecutiveDoubles[i] += 1
                    print("Congrats on rolling your first double!  You get to move.")
                else:
                    print("Sorry, you did not roll a double!  Try again next time.")
                    print("Current positions: " + str(currentSpaces))
                    continue

            # Runs a regular turn if player has already rolled an initial double to start
            if initialDouble[i]:
                currentSpaces = executeRoll(currentRoll[2], currentSpaces, i, initialDouble)

                # Checks for doubles (if it wasn't already checked with initial double)
                if not firstRoll:
                    newSpacesDoubles = trackDoubles(currentRoll, currentSpaces, i, consecutiveDoubles, initialDouble)
                    currentSpaces, consecutiveDoubles = newSpacesDoubles[0], newSpacesDoubles[1]
                print("Current doubles: " + str(consecutiveDoubles))

                # Checks for win condition (player reaching space #50)
                if currentSpaces[i] == 50:
                    winner = True
                    print("Player " + str(i + 1) + " wins!")

                    # Repeatedly asks for user to play again until they choose valid input
                    while True:
                        playAgain = input("Would you like to play again? [y/n] ")
                        if playAgain == "y":
                            print("You've chosen to play a new game!  Good choice.")
                            break
                        elif playAgain == "n":
                            print("You've chosen to stop playing.  No fun.")
                            break
                        else:
                            print("You must choose y or n!")
                            continue

                    if playAgain == "y":
                        break
                    else:
                        newGame = False
                        print("I hope you enjoyed playing!")
                        break
                    
                else:
                    continue
